"use strict";
/*
 * Copyright (c) Testmo GmbH (Berlin, Germany)
 * All rights reserved.
 * contact@testmo.com - www.testmo.com
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutomationRunCompleteCommand = void 0;
var commander = __importStar(require("commander"));
var logger_1 = require("../lib/logger");
var command_1 = require("../core/command");
var automationRunComplete_1 = require("../controller/automationRunComplete");
var AutomationRunCompleteCommand = /** @class */ (function (_super) {
    __extends(AutomationRunCompleteCommand, _super);
    function AutomationRunCompleteCommand() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'automation:run:complete';
        _this.description = 'Marks a test automation run as completed';
        _this.help = "Use this command to mark a test automation run you previously started with\nautomation:run:create as completed. Once the test run has been completed, it\ncannot receive additional threads and test results.\n\nYou should call this command after all your CI test tasks have been completed for\nthis run and after your last call to automation:run:submit-thread.\n\nPlease note that you do not need to complete a run you have started with\nautomation:run:submit. It is automatically completed after the results have been\nuploaded.\n\nBy default Testmo measures the run time by looking at the time difference between\ncreate and complete. In most situations this is the recommended approach as it\nresults in accurate automation time measurement. You can use the --no-measure-elapsed\noption to disable this behavior. The time of the test run is then based on the\nlongest running thread.\n\nMake sure to set the API authentication token as TESTMO_TOKEN environment variable.\nYou can either add an authentication token for your user in your profile settings\nin Testmo. Or your Testmo admin can add a separate API user just for authentication.";
        _this.examples = "The following example completes a running automation run:\n\n$ TESTMO_TOKEN=******** testmo automation:run:complete \\\n    --instance https://<your-name>.testmo.net \\\n    --run-id 1\n\nTo also include any additional resources previously stored in a file with the\nautomation:resources:* commands, such as custom fields, links and artifacts,\nspecify the resource file with the --resources option:\n\n$ TESTMO_TOKEN=******** testmo automation:run:complete \\\n    <other-options> \\\n    --resources testmo-resources.json";
        return _this;
    }
    AutomationRunCompleteCommand.prototype.buildCommand = function () {
        var command = new commander.Command(this.name);
        command.requiredOption('--instance <url>', 'Required: The full address of your Testmo instance (https://***.testmo.net)');
        command.requiredOption('--run-id <id>', 'Required: The ID of the run to be completed (returned by automation:run:create)');
        command.option('--no-measure-elapsed', 'By default Testmo measures the run time by looking at the time difference between create and complete. This option disables this behavior. The test run time is then based on the longest running thread');
        command.option('--resources <file>', 'An optional JSON file with custom fields, links and artifacts (can be built with the automation:resources commands)');
        return command;
    };
    AutomationRunCompleteCommand.prototype.run = function (commandOptions, commonOptions, subCommand) {
        return __awaiter(this, void 0, void 0, function () {
            var controller;
            return __generator(this, function (_a) {
                controller = new automationRunComplete_1.AutomationRunComplete();
                return [2 /*return*/, controller.run({
                        testmoInstanceAddress: this.trimRequiredArgument(commandOptions.instance),
                        testmoApiToken: this.trimOptionalArgument(process.env.TESTMO_TOKEN),
                        runId: this.trimRequiredArgument(commandOptions.runId),
                        measureElapsed: commandOptions.measureElapsed,
                        resourceFile: this.trimOptionalArgument(commandOptions.resources),
                        onAfterResources: function (resources) {
                            logger_1.logger.debug("Found ".concat(resources.fields.length, " fields, ").concat(resources.links.length, " links and ").concat(resources.artifacts.length, " artifacts"));
                        },
                        onAfterRunComplete: function () {
                            logger_1.logger.info('Marked the test run as completed');
                        },
                    })];
            });
        });
    };
    return AutomationRunCompleteCommand;
}(command_1.Command));
exports.AutomationRunCompleteCommand = AutomationRunCompleteCommand;
