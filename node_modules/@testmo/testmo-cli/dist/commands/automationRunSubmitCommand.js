"use strict";
/*
 * Copyright (c) Testmo GmbH (Berlin, Germany)
 * All rights reserved.
 * contact@testmo.com - www.testmo.com
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutomationRunSubmitCommand = void 0;
var commander = __importStar(require("commander"));
var logger_1 = require("../lib/logger");
var cli_progress_1 = __importDefault(require("cli-progress"));
var command_1 = require("../core/command");
var automationRunSubmit_1 = require("../controller/automationRunSubmit");
var AutomationRunSubmitCommand = /** @class */ (function (_super) {
    __extends(AutomationRunSubmitCommand, _super);
    function AutomationRunSubmitCommand() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'automation:run:submit';
        _this.description = 'Creates a new test automation run, submits test results and completes the run in a single step';
        _this.help = "Use this command to create a new test automation run, submit test results and\ncomplete the run in a single step. That is, use this command if you don't run your\ntests in multiple parallel threads. There are two typical ways to use this command:\n\n- Run this command after your tests finished and after your test result reports\n  were generated. This command then uploads your test results.\n\n  $ testmo automation:run:submit [options]\n\nOR\n\n- You can alternatively pass the executable/command line to run your tests to this\n  command. The command then also captures the output of your tests and measures\n  the exact time. The output and time are then also sent to Testmo.\n\n  $ testmo automation:run:submit [options] -- <your-test-run-command> [options]\n\nIn both scenarios the command expects that your test results are generated and\nreported as JUnit XML files. Practically any test automation tool can report or\nconvert test results to this format. The list of report files can be specified with\nthe --results option:\n\ntestmo automation:run:submit [options] --results reports/*.xml\n\nIt is also possible to use recursive search by specifying a quoted single option\nto be evaluated by 'glob' (don't forget the quotes):\n\ntestmo automation:run:submit [options] --results \"reports/**/*.xml\"\n\nThe command automatically detects if any found files look like a valid JUnit XML\nreport and ignores other files. By default, detected JUnit XML files that fail to\nparse throw an error.\n\nMake sure to set the API authentication token as TESTMO_TOKEN environment variable.\nYou can either add an authentication token for your user in your profile settings\nin Testmo. Or your Testmo admin can add a separate API user just for authentication.";
        _this.examples = "You can create a test automation run and submit test results after your test run:\n\n$ TESTMO_TOKEN=******** testmo automation:run:submit \\\n    --instance https://<your-name>.testmo.net \\\n    --project-id 1 \\\n    --name \"New test run\" \\\n    --source \"backend-unit\" \\\n    --results reports/*.xml\n\nYou can additionally pass the executable/command line for your test automation tool\nas the last parameter after the special -- option. The command then executes your\ntool and captures the full output and measures the execution time. Both are\nincluded in the result test automation run in Testmo (note the space after --):\n\n$ TESTMO_TOKEN=******** testmo automation:run:submit \\\n    --instance https://<your-name>.testmo.net \\\n    --project-id 1 \\\n    --name \"New test run\" \\\n    --source \"backend-unit\" \\\n    --results reports/*.xml \\\n    -- npm test <-- replace this line with your testing tool command line\n      ^ space!\n\nTo also include any additional resources previously stored in a file with the\nautomation:resources:* commands, such as custom fields, links and artifacts,\nspecify the resource file with the --resources option:\n\n$ TESTMO_TOKEN=******** testmo automation:run:submit \\\n    <other-options> \\\n    --resources testmo-resources.json";
        return _this;
    }
    AutomationRunSubmitCommand.prototype.buildCommand = function () {
        var command = new commander.Command(this.name);
        command.usage('[options] -- [executable]');
        command.requiredOption('--instance <url>', 'Required: The full address of your Testmo instance (https://***.testmo.net)');
        command.requiredOption('--project-id <id>', 'Required: The ID of the project this run is added to');
        command.requiredOption('--name <name>', 'Required: The name of the newly created test run');
        command.requiredOption('--source <source>', 'Required: The name of the source for this run and future runs of this same source/suite');
        command.requiredOption('--results <files...>', 'Required: Result log files (in JUnit XML format). If you pass a single quoted parameter, it is evaluated by Node\'s `glob` to resolve files (allowing recursive search, see example below)');
        command.option('--tags <tags...>', 'Tags for the new run. Tags can also be used to automatically link this run to milestones');
        command.option('--config <name>', 'Automatically find an existing configuration for this run based on the config name');
        command.option('--config-id <id>', 'Or specify a configuration by using the config\'s ID');
        command.option('--milestone <name>', 'Automatically find an existing milestone for this run based on the milestone name');
        command.option('--milestone-id <id>', 'Or specify a milestone by using the milestone\'s ID');
        command.option('--resources <file>', 'An optional JSON file with custom fields, links and artifacts (can be built with the automation:resources commands)');
        command.requiredOption('--ignore-parse-error', 'Ignore result file parsing errors and upload remaining successfully parsed files', false);
        command.requiredOption('--exec-suppress', 'Suppress standard output (stdout) of passed executable', false);
        command.requiredOption('--exec-stop-error', 'Stop and don\'t create a run if the passed executable failed (exit code not 0)', false);
        return command;
    };
    AutomationRunSubmitCommand.prototype.run = function (commandOptions, commonOptions, subCommand) {
        return __awaiter(this, void 0, void 0, function () {
            var controller, progressBar, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        controller = new automationRunSubmit_1.AutomationRunSubmit();
                        progressBar = new cli_progress_1.default.SingleBar({
                            format: 'Uploading: [{bar}] {percentage}% | ETA: {eta}s | {value}/{total} tests',
                        }, cli_progress_1.default.Presets.shades_grey);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, controller.run({
                                testmoInstanceAddress: this.trimRequiredArgument(commandOptions.instance),
                                testmoApiToken: this.trimOptionalArgument(process.env.TESTMO_TOKEN),
                                projectId: this.trimRequiredArgument(commandOptions.projectId),
                                name: this.trimRequiredArgument(commandOptions.name),
                                source: this.trimRequiredArgument(commandOptions.source),
                                resultFiles: this.trimRequiredArgumentList(commandOptions.results),
                                tags: this.trimOptionalArgumentList(commandOptions.tags),
                                config: this.trimOptionalArgument(commandOptions.config),
                                configId: this.trimOptionalArgument(commandOptions.configId),
                                milestone: this.trimOptionalArgument(commandOptions.milestone),
                                milestoneId: this.trimOptionalArgument(commandOptions.milestoneId),
                                resourceFile: this.trimOptionalArgument(commandOptions.resources),
                                ignoreParseError: commandOptions.ignoreParseError,
                                executableSuppressStdout: commandOptions.execSuppress,
                                executableStopOnError: commandOptions.execStopError,
                                executableArgs: subCommand.args,
                                onAfterExecute: function (elapsed, exitCode) {
                                    logger_1.logger.info("Program executed in ".concat(elapsed / 1000000, " seconds with exit code ").concat(exitCode));
                                },
                                onAfterResources: function (resources) {
                                    logger_1.logger.info("Found ".concat(resources.fields.length, " fields, ").concat(resources.links.length, " links and ").concat(resources.artifacts.length, " artifacts"));
                                },
                                onBeforeCollect: function () {
                                    logger_1.logger.info('Collecting log files ..');
                                },
                                onAfterCollect: function (fileCount, results) {
                                    logger_1.logger.info("Found ".concat(fileCount, " result files with a total of ").concat(results.tests.length, " tests"));
                                },
                                onAfterRunCreate: function (runId) {
                                    logger_1.logger.info("Created new test automation run (ID: ".concat(runId, ")"));
                                },
                                onAfterThreadCreate: function (threadId) {
                                    logger_1.logger.info("Created new thread (ID: ".concat(threadId, ")"));
                                },
                                onBeforeSubmit: function (total) {
                                    logger_1.logger.info('Sending tests to Testmo ..');
                                    if (commonOptions.ansi) {
                                        if (commonOptions.debug) {
                                            logger_1.logger.debug("Starting to submit tests (".concat(total, ")"));
                                        }
                                        else {
                                            progressBar.start(total, 0);
                                        }
                                    }
                                },
                                onSubmit: function (current, total) {
                                    if (commonOptions.ansi) {
                                        if (commonOptions.debug) {
                                            logger_1.logger.debug("Submitting tests (".concat(current, "/").concat(total, ")"));
                                        }
                                        else {
                                            progressBar.update(current);
                                        }
                                    }
                                },
                                onAfterSubmit: function (total) {
                                    if (commonOptions.ansi) {
                                        if (commonOptions.debug) {
                                            logger_1.logger.debug("Done submitting tests (".concat(total, ")"));
                                        }
                                        else {
                                            progressBar.stop();
                                        }
                                    }
                                    logger_1.logger.info('Successfully sent tests and completed run');
                                },
                                onAfterRunComplete: function () {
                                    logger_1.logger.info('Marked the run as completed');
                                },
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        err_1 = _a.sent();
                        // @ts-ignore
                        if (progressBar.isActive) {
                            progressBar.stop();
                        }
                        throw err_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    return AutomationRunSubmitCommand;
}(command_1.Command));
exports.AutomationRunSubmitCommand = AutomationRunSubmitCommand;
