"use strict";
/*
 * Copyright (c) Testmo GmbH (Berlin, Germany)
 * All rights reserved.
 * contact@testmo.com - www.testmo.com
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutomationRunSubmitThreadCommand = void 0;
var commander = __importStar(require("commander"));
var logger_1 = require("../lib/logger");
var cli_progress_1 = __importDefault(require("cli-progress"));
var command_1 = require("../core/command");
var automationRunSubmitThread_1 = require("../controller/automationRunSubmitThread");
var AutomationRunSubmitThreadCommand = /** @class */ (function (_super) {
    __extends(AutomationRunSubmitThreadCommand, _super);
    function AutomationRunSubmitThreadCommand() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'automation:run:submit-thread';
        _this.description = 'Creates a new thread for an existing run, submits test results and completes the thread';
        _this.help = "Use this command to add a new thread to an existing running test automation run,\nsubmit test results and complete the thread in a single step. You would use this\ncommand to submit the results of a single (parallel) CI task to an active run.\n\nIf you just want to create a test run with a single thread (i.e. a non-parallel single\nCI task), you would just use the automation:run:submit task instead.\n\nThere are two typical ways to use this command:\n\n- Run this command in your parallel CI task after your tests finished and after your\n  test result reports were generated. This command then uploads your test results.\n\n  $ testmo automation:run:submit-thread [options]\n\nOR\n\n- You can alternatively pass the executable/command line to run your tests to this\n  command. The command then also captures the output of your tests and measures\n  the exact time. The output and time are then also sent to Testmo.\n\n  $ testmo automation:run:submit-thread [options] -- <your-test-run-command> [options]\n\nIn both scenarios the command expects that your test results are generated and\nreported as JUnit XML files. Practically any test automation tool can report or\nconvert test results to this format. The list of report files can be specified with\nthe --results option:\n\ntestmo automation:run:submit-thread [options] --results reports/*.xml\n\nIt is also possible to use recursive search by specifying a quoted single option\nto be evaluated by 'glob' (don't forget the quotes):\n\ntestmo automation:run:submit-thread [options] --results \"reports/**/*.xml\"\n\nThe command automatically detects if any found files look like a valid JUnit XML\nreport and ignores other files. By default, detected JUnit XML files that fail to\nparse throw an error.\n\nMake sure to set the API authentication token as TESTMO_TOKEN environment variable.\nYou can either add an authentication token for your user in your profile settings\nin Testmo. Or your Testmo admin can add a separate API user just for authentication.";
        _this.examples = "You can create a new thread and submit test results after your test run:\n\n$ TESTMO_TOKEN=******** testmo automation:run:submit-thread \\\n    --instance https://<your-name>.testmo.net \\\n    --run-id 1 \\\n    --results reports/*.xml\n\nYou can additionally pass the executable/command line for your test automation tool\nas the last parameter after the special -- option. The command then executes your\ntool and captures the full output and measures the execution time. Both are\nincluded in the result test automation run in Testmo (note the space after --):\n\n$ TESTMO_TOKEN=******** testmo automation:run:submit-thread \\\n    --instance https://<your-name>.testmo.net \\\n    --run-id 1 \\\n    --results reports/*.xml \\\n    -- npm test <-- replace this line with your testing tool command line\n      ^ space!\n\nTo also include any additional resources previously stored in a file with the\nautomation:resources:* commands, such as custom fields, links and artifacts,\nspecify the resource file. You can add resources to the run and/or thread by\nusing the --run-resources and --thread-resources option. Note that links\nare only support for runs and are ignored for threads.\n\n$ TESTMO_TOKEN=******** testmo automation:run:submit-thread \\\n    <other-options> \\\n    --run-resources testmo-run-resources.json \\\n    --thread-resources testmo-thread-resources.json";
        return _this;
    }
    AutomationRunSubmitThreadCommand.prototype.buildCommand = function () {
        var command = new commander.Command(this.name);
        command.usage('[options] -- [executable]');
        command.requiredOption('--instance <url>', 'Required: The full address of your Testmo instance (https://***.testmo.net)');
        command.requiredOption('--run-id <id>', 'Required: The ID of the run this new thread should be added to (returned by automation:run:create');
        command.requiredOption('--results <files...>', 'Required: Result log files (in JUnit XML format). If you pass a single quoted parameter, it is evaluated by Node\'s `glob` to resolve files (allowing recursive search, see example below)');
        command.option('--run-resources <file>', 'An optional JSON file with custom fields, links and artifacts (can be built with the automation:resources commands) for the existing run');
        command.option('--thread-resources <file>', 'An optional JSON file with custom fields and artifacts (can be built with the automation:resources commands) for the new thread');
        command.requiredOption('--ignore-parse-error', 'Ignore result file parsing errors and upload remaining successfully parsed files', false);
        command.requiredOption('--exec-suppress', 'Suppress standard output (stdout) of passed executable', false);
        command.requiredOption('--exec-stop-error', 'Stop and don\'t create a run if the passed executable failed (exit code not 0)', false);
        return command;
    };
    AutomationRunSubmitThreadCommand.prototype.run = function (commandOptions, commonOptions, subCommand) {
        return __awaiter(this, void 0, void 0, function () {
            var controller, progressBar, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        controller = new automationRunSubmitThread_1.AutomationRunSubmitThread();
                        progressBar = new cli_progress_1.default.SingleBar({
                            format: 'Uploading: [{bar}] {percentage}% | ETA: {eta}s | {value}/{total} tests',
                        }, cli_progress_1.default.Presets.shades_grey);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, controller.run({
                                testmoInstanceAddress: this.trimRequiredArgument(commandOptions.instance),
                                testmoApiToken: this.trimOptionalArgument(process.env.TESTMO_TOKEN),
                                runId: this.trimRequiredArgument(commandOptions.runId),
                                resultFiles: this.trimRequiredArgumentList(commandOptions.results),
                                runResourceFile: this.trimOptionalArgument(commandOptions.runResources),
                                threadResourceFile: this.trimOptionalArgument(commandOptions.threadResources),
                                ignoreParseError: commandOptions.ignoreParseError,
                                executableSuppressStdout: commandOptions.execSuppress,
                                executableStopOnError: commandOptions.execStopError,
                                executableArgs: subCommand.args,
                                onAfterExecute: function (elapsed, exitCode) {
                                    logger_1.logger.info("Program executed in ".concat(elapsed / 1000000, " seconds with exit code ").concat(exitCode));
                                },
                                onAfterRunResources: function (resources) {
                                    logger_1.logger.info("Found ".concat(resources.fields.length, " fields, ").concat(resources.links.length, " links and ").concat(resources.artifacts.length, " artifacts for the run"));
                                },
                                onAfterThreadResources: function (resources) {
                                    logger_1.logger.info("Found ".concat(resources.fields.length, " fields and ").concat(resources.artifacts.length, " artifacts for the thread"));
                                },
                                onBeforeCollect: function () {
                                    logger_1.logger.info('Collecting log files ..');
                                },
                                onAfterCollect: function (fileCount, results) {
                                    logger_1.logger.info("Found ".concat(fileCount, " result files with a total of ").concat(results.tests.length, " tests"));
                                },
                                onAfterThreadCreate: function (threadId) {
                                    logger_1.logger.info("Created new thread (ID: ".concat(threadId, ")"));
                                },
                                onBeforeSubmit: function (total) {
                                    logger_1.logger.info('Sending tests to Testmo ..');
                                    if (commonOptions.ansi) {
                                        if (commonOptions.debug) {
                                            logger_1.logger.debug("Starting to submit tests (".concat(total, ")"));
                                        }
                                        else {
                                            progressBar.start(total, 0);
                                        }
                                    }
                                },
                                onSubmit: function (current, total) {
                                    if (commonOptions.ansi) {
                                        if (commonOptions.debug) {
                                            logger_1.logger.debug("Submitting tests (".concat(current, "/").concat(total, ")"));
                                        }
                                        else {
                                            progressBar.update(current);
                                        }
                                    }
                                },
                                onAfterSubmit: function (total) {
                                    if (commonOptions.ansi) {
                                        if (commonOptions.debug) {
                                            logger_1.logger.debug("Done submitting tests (".concat(total, ")"));
                                        }
                                        else {
                                            progressBar.stop();
                                        }
                                    }
                                    logger_1.logger.info('Successfully sent tests and completed thread');
                                },
                                onAfterThreadComplete: function () {
                                    logger_1.logger.info('Marked the thread as completed');
                                },
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        err_1 = _a.sent();
                        // @ts-ignore
                        if (progressBar.isActive) {
                            progressBar.stop();
                        }
                        throw err_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    return AutomationRunSubmitThreadCommand;
}(command_1.Command));
exports.AutomationRunSubmitThreadCommand = AutomationRunSubmitThreadCommand;
