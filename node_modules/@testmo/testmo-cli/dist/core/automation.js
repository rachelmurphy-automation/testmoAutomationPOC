"use strict";
/*
 * Copyright (c) Testmo GmbH (Berlin, Germany)
 * All rights reserved.
 * contact@testmo.com - www.testmo.com
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutomationRunResults = exports.validateSource = void 0;
var fs_1 = __importDefault(require("fs"));
var parsers_1 = require("../parsers");
var logger_1 = require("../lib/logger");
function validateSource(name) {
    return /^[a-zA-Z][a-zA-Z0-9-]+$/.test(name);
}
exports.validateSource = validateSource;
var AutomationRunResults = /** @class */ (function () {
    function AutomationRunResults(strictMode) {
        this.elapsed = 0;
        this.fields = [];
        this.tests = [];
        this.strictMode = strictMode;
    }
    AutomationRunResults.prototype.loadFromFiles = function (files) {
        var _a, _b;
        var parsers = (0, parsers_1.getParsers)();
        var fileResults = [];
        var parsedFileCount = 0;
        for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
            var file = files_1[_i];
            logger_1.logger.debug("Trying to detect format for file: ".concat(file));
            var formatDetected = false;
            var content = fs_1.default.readFileSync(file, { encoding: 'utf8' });
            for (var _c = 0, parsers_2 = parsers; _c < parsers_2.length; _c++) {
                var parser = parsers_2[_c];
                if (parser.detect(content, file)) {
                    logger_1.logger.debug("Detected format as \"".concat(parser.name, "\", now parsing results"));
                    try {
                        var parsedResults = parser.parse(content);
                        parsedFileCount++;
                        var info = [
                            "".concat(parsedResults.fields.length, " fields"),
                            "".concat(parsedResults.tests.length, " tests"),
                        ];
                        if (parsedResults.elapsed !== undefined) {
                            info.push("".concat(parsedResults.elapsed / 1000000, "s elapsed"));
                        }
                        else {
                            info.push('no total elapsed time');
                        }
                        logger_1.logger.debug('Found: ' + info.join(', '));
                        fileResults.push(parsedResults);
                    }
                    catch (err) {
                        logger_1.logger.error("Failed to parse file: ".concat(file));
                        if (this.strictMode) {
                            throw err;
                        }
                        else {
                            logger_1.logger.exception(err);
                        }
                    }
                    formatDetected = true;
                    break;
                }
            }
            if (!formatDetected) {
                logger_1.logger.debug('Format could not be detected');
            }
        }
        // Reduce file results into a single result
        this.elapsed = 0;
        this.fields = [];
        this.tests = [];
        for (var _d = 0, fileResults_1 = fileResults; _d < fileResults_1.length; _d++) {
            var fileResult = fileResults_1[_d];
            (_a = this.tests).push.apply(_a, fileResult.tests);
            (_b = this.fields).push.apply(_b, fileResult.fields);
            if (fileResult.elapsed !== undefined) {
                this.elapsed += fileResult.elapsed;
            }
            else {
                this.elapsed += fileResult.tests.reduce(function (total, test) {
                    return total + (test.elapsed || 0);
                }, 0);
            }
        }
        return parsedFileCount;
    };
    return AutomationRunResults;
}());
exports.AutomationRunResults = AutomationRunResults;
